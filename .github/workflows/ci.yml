name: CI

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

# Note: this workflow is careful to avoid failing for forked PRs where secrets are not available.

jobs:
  validate-secrets:
    name: Validate required secrets (main branch only)
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Check required secrets
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          echo "Validating secrets for main branch run"
          missing=0
          if [ -z "${DATABASE_URL:-}" ]; then echo "::error::Missing SECRET: DATABASE_URL"; missing=1; fi
          if [ -z "${POSTGRES_USER:-}" ]; then echo "::warning::Missing SECRET: POSTGRES_USER (service fallback may work)"; fi
          if [ -z "${POSTGRES_PASSWORD:-}" ]; then echo "::warning::Missing SECRET: POSTGRES_PASSWORD (service fallback may work)"; fi
          if [ "$missing" -eq 1 ]; then exit 1; fi

  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        ports:
          - 5432:5432
        env:
          # Use repository secrets when present, otherwise fall back to sensible defaults
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'postgres' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'postgres' }}
        options: >-
          --health-cmd="pg_isready -U ${{ secrets.POSTGRES_USER || 'postgres' }} -d ${{ secrets.POSTGRES_DB || 'postgres' }}"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=10
    env:
      # Provide a sensible fallback DATABASE_URL when the secret is missing so hosted CI runs don't break
      DATABASE_URL: ${{ secrets.DATABASE_URL || format('postgresql://{0}:{1}@localhost:5432/{2}', secrets.POSTGRES_USER || 'postgres', secrets.POSTGRES_PASSWORD || 'postgres', secrets.POSTGRES_DB || 'postgres') }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci --workspaces

      - name: Show DB diagnostics
        run: |
          echo "DATABASE_URL=${DATABASE_URL}"
          echo "POSTGRES_USER=${{ secrets.POSTGRES_USER || 'postgres' }}"
          echo "POSTGRES_DB=${{ secrets.POSTGRES_DB || 'postgres' }}"

      - name: Guard EXPOSE_TEST_TOKENS
        run: |
          if [ "${EXPOSE_TEST_TOKENS:-}" = "true" ]; then
            echo "::error::EXPOSE_TEST_TOKENS must not be enabled in hosted CI"
            exit 1
          fi
        env:
          EXPOSE_TEST_TOKENS: ${{ secrets.EXPOSE_TEST_TOKENS }}

      - name: Wait for Postgres
        run: |
          # Try using pg_isready first, fall back to nc if the helper is not available.
          for i in {1..60}; do
            if command -v pg_isready >/dev/null 2>&1; then
              if pg_isready -h localhost -p 5432 -U "${{ secrets.POSTGRES_USER || 'postgres' }}" -d "${{ secrets.POSTGRES_DB || 'postgres' }}" >/dev/null 2>&1; then
                echo "Postgres is accepting connections" && exit 0
              fi
            else
              if nc -z localhost 5432 >/dev/null 2>&1; then
                echo "Postgres is accepting connections" && exit 0
              fi
            fi
            echo "Waiting for Postgres... ($i/60)";
            sleep 1
          done
          echo "::error::Postgres did not become available in time" && exit 1

      - name: Build (optional)
        run: npm run build --workspaces --if-present

      - name: Run DB migrations (if available)
        run: |
          npm run migrate --if-present || node database/migrate.js || true

      # single guard above prevents EXPOSE_TEST_TOKENS from being set in hosted runs

      - name: Skip heavy tests here (tests run in workspace matrix)
        run: echo "Skipping monorepo tests in this job — tests run in parallel per-workspace"

  workspace-tests:
    name: Workspace tests (parallel)
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - workspace: "@tg-payment/core"
            package: core
            needs_db: true
          - workspace: "@tg-payment/api"
            package: api
            needs_db: true
          - workspace: "@tg-payment/dashboard"
            package: dashboard
            needs_db: false
          - workspace: "@tg-payment/sdk"
            package: sdk
            needs_db: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Use Node.js 20 and cache npm
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Install dependencies for workspace
        run: npm ci --workspace="${{ matrix.workspace }}" --if-present

      - name: Check whether workspace changed in this PR/push
        id: changed-check
        run: |
          set -euo pipefail
          echo "Determining changed files for workflow run..."
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF=${{ github.event.pull_request.base.ref }}
            echo "Fetching base ref: $BASE_REF"
            git fetch origin $BASE_REF --depth=1 || true
            CHANGED=$(git diff --name-only origin/${BASE_REF}...HEAD || true)
          else
            # for push events, check commits in the push
            CHANGED=$(git --no-pager diff --name-only HEAD~5..HEAD || true)
          fi
          echo "Changed files:\n$CHANGED"
          echo "$CHANGED" | grep -E -q "^packages/${{ matrix.package }}/" && echo "workspace_changed=true" >> $GITHUB_ENV || echo "workspace_changed=false" >> $GITHUB_ENV

      - name: Build package (if present)
        run: npm run build --workspace="${{ matrix.workspace }}" --if-present

      - name: Run package tests
        run: |
          # workspace_changed is set by the previous step via $GITHUB_ENV
          if [ "${workspace_changed:-false}" != "true" ]; then
            echo "No changes detected in workspace ${{ matrix.workspace }}, skipping tests to save CI time."
            exit 0
          fi
          echo "Running tests for workspace ${{ matrix.workspace }}"
          if [ "${{ matrix.needs_db }}" = "true" ]; then
            echo "This workspace requires a DB — starting a local Postgres service in job"
            docker run -d --name test-pg -e POSTGRES_PASSWORD=postgres -e POSTGRES_USER=postgres -e POSTGRES_DB=postgres -p 5432:5432 postgres:16 || true
            # give postgres a moment to start
            for i in {1..30}; do nc -z localhost 5432 && break || sleep 1; done
            export DATABASE_URL=postgresql://postgres:postgres@localhost:5432/postgres
          fi
            npm run test --workspace="${{ matrix.workspace }}" --if-present

  e2e-fixture:
    # This job is intended to run on a self-hosted runner with Docker available.
    # It runs when manually triggered or when a pull request is labeled `run-e2e`.
    runs-on: [self-hosted, linux, docker]
    needs: test
    if: |
      github.event_name == 'workflow_dispatch' || (
        github.event_name == 'pull_request' && contains(join(github.event.pull_request.labels.*.name, ','), 'run-e2e')
      )
    env:
      USE_TESTCONTAINERS: 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci --workspaces

      - name: Prepare DB and run tests (fixture-backed)
        run: |
          export DATABASE_URL="unused"
          # The tests will start Testcontainers and run migrations themselves when USE_TESTCONTAINERS=true
          npm run test --workspaces --if-present
        env:
          USE_TESTCONTAINERS: 'true'

  docker-smoke:
    name: Build Docker image + smoke test
    runs-on: ubuntu-latest
    needs: test
    # This job intentionally avoids reading repository secrets so it works for forked PRs
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build docker image
        run: |
          docker build -t tg-payment-gateway:ci .

      - name: Start Postgres and Redis containers
        run: |
          docker run -d --name test-pg -e POSTGRES_PASSWORD=postgres -e POSTGRES_USER=postgres -e POSTGRES_DB=postgres -p 5433:5432 postgres:16 || true
          docker run -d --name test-redis -p 6380:6379 redis:7-alpine || true
          # wait for services
          for i in {1..60}; do
            if docker exec test-pg pg_isready -h localhost -p 5432 -U postgres >/dev/null 2>&1; then echo "Postgres ready" && break; fi
            echo "Waiting for Postgres... ($i/60)"; sleep 1
          done
          for i in {1..30}; do
            if docker exec test-redis redis-cli ping >/dev/null 2>&1; then echo "Redis ready" && break; fi
            echo "Waiting for Redis... ($i/30)"; sleep 1
          done

      - name: Run container for smoke testing
        run: |
          # run the built image and link to the test DB/Redis
          docker run -d --name tg_payment_api_ci --link test-pg:db --link test-redis:redis -e DATABASE_URL=postgresql://postgres:postgres@db:5432/postgres -e REDIS_URL=redis://redis:6379 -e PORT=3000 -p 3000:3000 tg-payment-gateway:ci || true
          # wait for the /health endpoint
          for i in {1..60}; do
            if curl -f --max-time 2 http://localhost:3000/health >/dev/null 2>&1; then echo "Health OK" && exit 0; fi
            echo "Waiting for /health... ($i/60)"; sleep 1
          done
          echo "::error::Health endpoint did not become ready" && exit 1

      - name: Collect logs and teardown
        if: always()
        run: |
          docker logs tg_payment_api_ci || true
          docker rm -f tg_payment_api_ci || true
          docker rm -f test-pg || true
          docker rm -f test-redis || true
